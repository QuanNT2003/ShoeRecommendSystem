# -*- coding: utf-8 -*-
"""SameProductServer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1llEjDwTiBnY1ja2aZE7o346Az0oJXxU_
"""

# Cài đặt các thư viện cần thiết
!pip install pandas numpy scikit-learn
!pip install tensorflow-recommenders --no-deps
!pip install tensorflow==2.15.0
!pip install flask flask-cors pyngrok

# Import các thư viện cần thiết
import tensorflow as tf
import tensorflow_recommenders as tfrs
import pandas as pd
import numpy as np
import pickle
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
from tensorflow.keras.layers import StringLookup, Embedding
from flask import Flask, jsonify, request
from flask_cors import CORS
from pyngrok import ngrok

from google.colab import drive
drive.mount('/content/drive')

# Đọc dữ liệu sản phẩm và đánh giá
product_data = pd.read_csv('/content/drive/MyDrive/Data/products.csv')
reviews_data = pd.read_csv('/content/drive/MyDrive/Data/reviews.csv')

# Xử lý NaN
product_data = product_data.fillna('')
reviews_data = reviews_data.fillna('')

# Đảm bảo các cột có kiểu dữ liệu đồng nhất
product_data = product_data.astype(str)
reviews_data = reviews_data.astype(str)

user_ids = reviews_data["user"].unique().astype(str)
user_ids = np.array(user_ids)  # Đảm bảo user_ids là một mảng numpy
print("User IDs:", user_ids)

product_ids = product_data["productId"].unique().astype(str)
product_ids = np.array(product_ids)  # Đảm bảo product_ids là một mảng numpy
print("Product IDs:", product_ids)

brands = product_data["brand"].unique().astype(str)
categories = product_data["category"].unique().astype(str)
classifies = product_data["classify"].unique().astype(str)

# Tạo các đối tượng StringLookup cho userId và productId
user_id_lookup = StringLookup(vocabulary=user_ids, mask_token=None)
product_id_lookup = StringLookup(vocabulary=product_ids, mask_token=None)
brand_lookup = StringLookup(vocabulary=brands, mask_token=None)
category_lookup = StringLookup(vocabulary=categories, mask_token=None)
classify_lookup = StringLookup(vocabulary=classifies, mask_token=None)

# Chuyển đổi và mã hóa dữ liệu reviews_data
reviews_data["user_id_encoded"] = user_id_lookup(reviews_data["user"])
reviews_data["product_id_encoded"] = product_id_lookup(reviews_data["productId"])
reviews_data["rating"] = reviews_data["rating"].astype(float)  # Đảm bảo rating là số thực

# Ghép dữ liệu sản phẩm vào reviews_data theo productId
merged_data = reviews_data.merge(product_data, on="productId", how="left")
merged_data["brand_encoded"] = brand_lookup(merged_data["brand"])
merged_data["category_encoded"] = category_lookup(merged_data["category"])
merged_data["classify_encoded"] = classify_lookup(merged_data["classify"])

# Tạo Dataset TensorFlow
train = tf.data.Dataset.from_tensor_slices({
    "user_id": tf.cast(merged_data["user_id_encoded"].values, tf.int32),
    "product_id": tf.cast(merged_data["product_id_encoded"].values, tf.int32),
    "brand": tf.cast(merged_data["brand_encoded"].values, tf.int32),
    "category": tf.cast(merged_data["category_encoded"].values, tf.int32),
    "classify": tf.cast(merged_data["classify_encoded"].values, tf.int32),
    "rating": tf.cast(merged_data["rating"].values, tf.float32)
}).batch(512)

test = tf.data.Dataset.from_tensor_slices({
    "user_id": tf.cast(merged_data["user_id_encoded"].values, tf.int32),
    "product_id": tf.cast(merged_data["product_id_encoded"].values, tf.int32),
    "brand": tf.cast(merged_data["brand_encoded"].values, tf.int32),
    "category": tf.cast(merged_data["category_encoded"].values, tf.int32),
    "classify": tf.cast(merged_data["classify_encoded"].values, tf.int32),
    "rating": tf.cast(merged_data["rating"].values, tf.float32)
}).batch(512).cache()

# Tạo Dataset cho product_ids
products_dataset = tf.data.Dataset.from_tensor_slices(product_ids).map(lambda x: tf.strings.as_string(x))

class ProductRecommendationModel(tfrs.Model):
    def __init__(self, user_ids, product_ids):
        super().__init__()

        # Tạo embedding cho người dùng và sản phẩm
        self.user_embedding = tf.keras.layers.Embedding(input_dim=len(user_ids) + 1, output_dim=32)
        self.product_embedding_layer = tf.keras.layers.Embedding(input_dim=len(product_ids) + 1, output_dim=32)

        # Tạo lớp BruteForce cho candidates với lớp embedding của sản phẩm
        self.candidate_model = tfrs.layers.factorized_top_k.BruteForce(self.product_embedding_layer)

        # Thiết lập nhiệm vụ truy xuất với lớp BruteForce
        self.task = tfrs.tasks.Retrieval(
            metrics=tfrs.metrics.FactorizedTopK(candidates=self.candidate_model)
        )

    def compute_loss(self, features, training=False):
        # Lấy embedding cho user và product
        user_embeddings = self.user_embedding(features["user"])
        product_embeddings = self.product_embedding_layer(features["productId"])

        # Kiểm tra kích thước
        print("User embeddings shape:", user_embeddings.shape)
        print("Product embeddings shape:", product_embeddings.shape)

        # Tính toán loss
        return self.task(user_embeddings, product_embeddings)


model = ProductRecommendationModel()
model.compile(optimizer=tf.keras.optimizers.Adagrad(learning_rate=0.1))
model.fit(train, epochs=5)
